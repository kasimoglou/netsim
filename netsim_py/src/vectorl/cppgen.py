"""
    C/C++ code generator
"""

from vectorl.typeinfo import *
from vectorl.expr import *
from vectorl.model import *
from models.mf import *

from simgen.utils import docstring_template

import io
from functools import wraps
from contextlib import contextmanager



class OutputStack:
    """
    This is a list of strings or lists of strings.
    Nested lists denote {}-blocks and are indented.
    """
    def __init__(self, indent=""):
        self.stack = []
        self.out = []
        self.indent = indent
    def push(self):
        self.stack.append(self.out)
        self.out = []
    def pop(self):
        current = self.out
        self.out = self.stack.pop()
        self.out.append(current)
    def __iadd__(self, line):
        assert isinstance(line,str)
        self.out.append(line)
        return self

    def output(self, fobj, indent="  "):
        if self.stack:
            raise RuntimeError("The stack is not empty")

        def output_entry(x,I):
            fobj.write(I)
            fobj.write(x)
            fobj.write('\n')


        def create_output(L, I):
            for x in L:
                if isinstance(x, list):
                    output_entry("{", I)
                    create_output(x, I+indent)
                    output_entry("}", I)
                else:    
                    output_entry(x,I)

        create_output(self.out, self.indent)

    def output_string(self):
        iostr = io.StringIO()
        self.output(iostr)
        return iostr.getvalue()


#
#  Decorator for mapping items to methods
#
cppgen_map = {}
def gen_item(item):
    "Decorator for switching on generation methods"
    def map_method(method):
        cppgen_map[item] = method
        return method
    return map_method



cpp_type = {
    BOOL: 'bool',
    INT: 'int',
    REAL: 'double',
    TIME: 'double'
}


@docstring_template
def cpp_var_declaration(tinfo, shape, name):
    "{{!tname}} {{!name}}{{!extents}}"
    tname = cpp_type[tinfo]
    extents = "".join("[%d]" % e  for e in shape)
    return locals()



class CppGenerator:
    """
    A C/C++ generator class.
    """

    def __init__(self, factory, base_name):
        '''
        The model factory and the base name for the output.
        '''
        # the model
        self.factory = factory
        self.base_name = base_name

        # the output
        self.cc = OutputStack()
        self.hh = OutputStack()

        # other
        self.name_counter = 0


    def getname(self, prefix):
        "Return a new unique variable name."
        self.name_counter += 1
        return "_%s%d" % (prefix,self.var_counter)


    def generate(self):
        "Start the generation process."

        text = """\
//------------------------------------------------
// Automatically generated by the vectorl compiler
// (changes will be overwritten)
//-------------------------------------------------
"""
        self.hh += text
        self.cc += text

        self.hh += "#ifndef __%s_HH" % self.base_name.upper()
        self.hh += "#define __%s_HH" % self.base_name.upper()
        self.hh += ""

        self.cc += ""
        self.cc += """#include "%s.hh" """ % self.base_name
        self.cc += ""

        self.generate_hh()
        self.generate_actions()
        
        #self.generate_class_decl()
        #self.generate_class_def()

        self.hh += ""
        self.hh += "#endif"

    def generate_hh(self):
        self.hh += "struct __vectorl_model";
        self.hh.push()
        for model in self.factory.models:
            self.hh += "struct _model_%s" % model.name
            self.hh.push()
            for v in model.variables:
                if v.name in v.model and v.model[v.name] is v:
                    self.hh += cpp_var_declaration(v.type, v.shape, v.name)+";"
            self.hh.pop()
            self.hh += "%s;" % model.name
            self.hh += ""



        self.hh.pop();
        self.hh += "vectorl_model;"


    def generate_handler_header(self, evt):
        pass


    def generate_actions(self):
        pass


