
from vectorl.typeinfo import *
from vectorl.expr import *
from vectorl.model import ModelFactory

from simgen.utils import docstring_template
import io


def emit_indented(m, values):
	'return a string with the contents of value indented by m tabs'
	with io.StringIO() as out:
		indent = '\t'*m
		for v in values:
			with io.StringIO(v) as f:
				for line in f.readlines():
					out.write(indent)
					out.write(line)
		return out.getvalue()


class CppGenerator:
	def __init__(self, factory, class_name):
		self.factory = factory
		self.output_cc = None
		self.output_hh = None
		self.class_name = class_name

	def generate(self):
		'This is the main function to perform the generation'
		self.generate_vars()
		self.generate_actions()
		#self.generate_expr()
		self.generate_class_decl()
		self.generate_class_def()


	def generate_class_decl(self):
		pieces = list(self.struct_src.values()) + list(self.action_decl.values())
		self.output_hh = self.class_decl(pieces)

	@docstring_template
	def class_decl(self, allval):
		"""\
//------------------------------------------------
// Automatically generated by the vectorl compiler
// (changes will be overwritten)
//-------------------------------------------------
#ifndef {{!cpp_label}}
#define {{!cpp_label}}

#include <boost/multi_array.hh>

struct {{self.class_name}} {
	
{{! body}}

};


#endif

"""
		cpp_label = self.class_name.upper()+"_HH"
		body = emit_indented(1, allval)
		return locals()


	def generate_class_def(self):
		pass


	def generate_vars(self):
		self.var_map = {}
		self.struct_src = {}

		for model in self.factory.models:
			self.struct_src[model.name] = self.generate_struct(model)


	def is_model_level(self, var):
		'''Return true iff a var is declared at the model level'''
		return var.name in var.model and var.model[var.name] is var


	@docstring_template
	def generate_struct(self, model):
		'''
struct _model_{{!model.name}} {

	// model-level variables
	% for var in model.variables:
	% if self.is_model_level(var):
	%  self.var_map[var] = "%s.%s" % (model.name, var.name)
    % if len(var.shape):
	{{!self.gen_type(var.type, var.shape)}} {{! var.name}} \
	{{! self.var_shape_initializer(var.shape)}}; // loc: {{var.origin}}
	% else:
	{{!self.gen_type(var.type, var.shape)}} {{! var.name}};  // loc: {{var.origin}}
	% end
	% end
	% end

} {{!model.name}};

'''
		return locals()

	@docstring_template
	def var_shape_initializer(self, shape):
		"{ boost::extents{{! ''.join('[%d]'%l for l in shape) }} }"
		#assert len(shape)
		return locals()

	def gen_type(self, tinfo, shape):
		if len(shape) ==0:
			return self.typemap[tinfo]
		else:
			return self.gen_array_type(tinfo, shape)

	typemap = {
		BOOL: 'bool',
		INT: 'int',
		REAL: 'double',
		TIME: 'double'
	}

	@docstring_template
	def gen_array_type(self, tinfo, shape):
		"boost::multi_array<{{self.typemap[tinfo]}} , {{len(shape)}}>"
		return locals()

	def generate_actions(self):
		self.action_decl = {}
		self.action_def = {}

		for event in self.factory.all_events():
			self.action_def[event] = self.generate_action(event)

	def generate_action(self, event):
		self.action_decl[event] = self.gen_action_decl(event)
		# mark cpp names of action params
		for var in event.variables:
			self.var_map[var] = var.name

		action_stmts = []
		for action in event.actions:
			stmt = self.generate_statement(action.statement)
			action_stmts.append(stmt)

	def mangled(self, *args):
		largs = ["%d%s"%(len(s),s) for s in args]
		return '_'.join(largs)

	@docstring_template
	def gen_action_decl(self, event):
		"""void on_{{!m_event}}({{!param_list}});
"""
		m_event = self.mangled(event.model.name, event.name)
		param_list = ', '.join(self.gen_param_decl(v) for v in event.variables)
		return locals()

	@docstring_template
	def gen_param_decl(self, var):
		"{{!type}} {{name}}"
		type = self.gen_type(var.type, var.shape)
		name = var.name
		return locals()

	def generate_statement():
		
		