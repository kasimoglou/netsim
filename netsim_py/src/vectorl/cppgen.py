
from vectorl.typeinfo import *
from vectorl.expr import *
from vectorl.model import *

from simgen.utils import docstring_template

import io
from functools import wraps
from contextlib import contextmanager

def emit_indented(m, values):
	'return a string with the contents of value indented by m tabs'
	with io.StringIO() as out:
		indent = '\t'*m
		for v in values:
			with io.StringIO(v) as f:
				for line in f.readlines():
					out.write(indent)
					out.write(line)
		return out.getvalue()

def emit_indented_blocks(values):
	"""Return a string for the recursive list 'values'.
	This list contains both strings and other lists.
	The contents are indented according the the nesting
	level, and returned as a single text.
	"""
	text_values = []
	for v in values:
		if isinstance(v, list):
			vtext = emit_indented_blocks(v)
			vitext = emit_indented(1, vtext)
			text_values.append('{')
			text_values.append(vitext)
			text_values.append('}')
		else:
			text_values.append(v)
	return emit_indented(0, text_values)




def shape_size(shape):
	"Return the total number of elements of an array or scalar"
	prod = 1
	for i in shape:
		prod *= i
	return prod


cppgen_map = {}

def gen_item(item):
	"Decorator for switching on generation methods"
	def map_method(method):
		cppgen_map[item] = method
		return method
	return map_method


@contextmanager
def nested_code(gen):
	gen.push_code()
	yield
	gen.pop_code()



class CppGenerator:
	def __init__(self, factory, class_name):
		self.factory = factory
		self.output_cc = None
		self.output_hh = None
		self.class_name = class_name

		self.code_stack = []
		self.code = []


	def push_code(self):
		curcode = self.code
		self.code_stack.append(code)
		self.code = list()

	def pop_code(self):
		curcode = self.code
		self.code = self.code_stack.pop()
		self.code.append(curcode)



	def generate(self):
		'This is the main function to perform the generation'
		self.generate_vars()
		self.generate_actions()
		#self.generate_expr()
		self.generate_class_decl()
		self.generate_class_def()


	def generate_class_decl(self):
		pieces = list(self.struct_src.values()) + list(self.action_decl.values())
		self.output_hh = self.class_decl(pieces)

	@docstring_template
	def class_decl(self, allval):
		"""\
//------------------------------------------------
// Automatically generated by the vectorl compiler
// (changes will be overwritten)
//-------------------------------------------------
#ifndef {{!cpp_label}}
#define {{!cpp_label}}

#include <boost/multi_array.hh>

struct {{self.class_name}} {
	
{{! body}}

};


#endif

"""
		cpp_label = self.class_name.upper()+"_HH"
		body = emit_indented(1, allval)
		return locals()


	def generate_class_def(self):
		action_text = []
		for event in self.action_def:
			atext = self.gen_action_def(event)
			action_text.append(atext)
		self.output_cc = self.gen_cc_file(action_text)


	@docstring_template
	def gen_cc_file(self, action_text):
		"""
#include "{{!self.class_name}}"

{{! actions}}
"""
		actions = "".join(action_text)		
		return locals()

	@docstring_template
	def gen_action_def(self, event):
		"""\
{{! header}}
{
{{! body}}
}

"""
		adef = self.action_def[event]
		# generate method header
		header = self.gen_action_def_header(event)

		# generate method body
		body = emit_indented(1, adef)
		return locals()


	@docstring_template
	def gen_action_def_header(self, event):
		"void {{!self.class_name}}::{{!mangled_name}}({{! param_list}})"
		mangled_name = self.mangled(event.model.name,event.name)
		param_list = self.gen_params_decl(event.variables)
		return locals()


	#------------------------------------------------------
	#
	# The variables
	#
	#------------------------------------------------------

	def generate_vars(self):
		self.var_map = {}
		self.struct_src = {}

		for model in self.factory.models:
			self.struct_src[model.name] = self.generate_struct(model)


	def is_model_level(self, var):
		'''Return true iff a var is declared at the model level'''
		return var.name in var.model and var.model[var.name] is var


	@docstring_template
	def generate_struct(self, model):
		'''
struct _model_{{!model.name}} {

	// model-level variables
	% for var in model.variables:
	% if self.is_model_level(var):
	%  self.var_map[var] = "%s.%s" % (model.name, var.name)
	{{!self.gen_var_decl(var.type, var.shape, var.name)}};
	% end
	% end

} {{!model.name}};

'''
		return locals()

	def gen_type(self, tinfo):
		return self.typemap[tinfo]

	typemap = {
		BOOL: 'bool',
		INT: 'int',
		REAL: 'double',
		TIME: 'double'
	}


	@docstring_template
	def gen_var_decl(self, tinfo, shape, name):
		"{{!tname}} {{!name}}{{!extents}}"
		tname = self.gen_type(tinfo)
		extents = "".join("[%d]" % e  for e in shape)
		return locals()

	#----------------------------------------------------
	#
	# Actions (statements)
	#
	#----------------------------------------------------


	def generate_actions(self):
		self.action_decl = {}
		self.action_def = {}

		for event in self.factory.all_events():
			self.action_def[event] = self.generate_action(event)



	def generate_action(self, event):
		self.action_decl[event] = self.gen_action_decl(event)
		# mark cpp names of action params
		for var in event.variables:
			self.var_map[var] = var.name

		action_stmts = []
		for action in event.actions:
			stmt = self.generate_statement(action.statement)
			action_stmts.append(stmt)
		return action_stmts

	def mangled(self, *args):
		largs = ["%d%s"%(len(s),s) for s in args]
		return '_'.join(largs)

	@docstring_template
	def gen_action_decl(self, event):
		"""void on_{{!m_event}}({{!param_list}});
"""
		m_event = self.mangled(event.model.name, event.name)
		param_list = self.gen_params_decl(event.variables)
		return locals()

	def gen_params_decl(self, vars):
		return ', '.join(self.gen_param_decl(v) for v in vars)

	@docstring_template
	def gen_param_decl(self, var):
		"{{!type}} {{!name}}"
		type = self.gen_type(var.type)
		name = var.name
		return locals()


	def generate_statement(self, stmt):
		method = cppgen_map[stmt.__class__]
		return method(self, stmt)


	@gen_item(Assignment)
	@docstring_template
	def generate_assign(self, stmt):
		"""\
// {{! stmt.origin}}
{	
}
"""
		lhs_var, lhs_code = self.generate_lvalue(stmt.lhs)
		rhs_var, rhs_code = self.generate_rvalue(stmt.rhs)

		lshape = stmt.lhs.shape
		rshape = stmt.rhs.shape

		if shape_size(lshape)==1:
			# we do not loop
			assert shape_size(rshape)==1
			assert len(lshape)>=len(rshape)
			code = ""
		else:
			pass
			# iteration: take all axes whose size is > 1

		return locals()


	def gen_assignment_size1(self, lhs_var, lshape, rhs_var, rshape):
		LHS = lhs_var + "[0]"*len(lshape)
		RHS = rhs_var + "[0]"*len(rshape)



	@gen_item(CodeBlock)
	@docstring_template
	def generate_code_block(self, stmt):
		"""\
{
{{! stmt}}
}
"""
		stmts = []
		for stmt in stmt.statements:
			stmts.append(self.generate_statement(stmt))
		stmt=emit_indented(1, stmts)
		return locals()		

	@gen_item(EmitStatement)
	@docstring_template
	def generate_emit(self, stmt):
		"""\
// {{! stmt.origin}}
{
	
}
"""
		return locals()

	@gen_item(PrintStatement)
	@docstring_template
	def generate_print(self, stmt):
		"""\
// {{! stmt.origin}}
{
	
}
"""
		return locals()

	@gen_item(IfStatement)
	@docstring_template
	def generate_if(self, stmt):
		"""\
// {{! stmt.origin}}
{
	
}
"""
		return locals()


	@gen_item(FExpr)
	def generate_fexpr(self, stmt):
		pass

	#-----------------------------------------------
	#
	# r-values (expressions)
	#
	#-----------------------------------------------
	def generate_rvalue(expr):		
		return self.generate_expr(expr)
		





	#-----------------------------------------------
	#
	# l-values
	#
	#-----------------------------------------------
	def generate_lvalue(expr, name):
		return ("", "")


